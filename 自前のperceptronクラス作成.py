# -*- coding: utf-8 -*-
"""3_perceptron.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1md6KINMGs8oc3mAWmyknAeY-tJsZGh5H
"""

from sklearn.datasets import load_digits
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.linear_model import Perceptron
import numpy as np

digits = load_digits()
train_X, test_X, train_y, test_y = train_test_split(digits.data, digits.target, random_state=0, test_size=0.1)

class MyPerceptron:
  def __init__(self,rho):
    self.rho=rho
    #クラス数
    self.n=0
    #パターンの次元
    self.d=0
    # 重みベクトルの配列
    self.w = np.zeros((0, 1))
    # 打ち切るエポックの上限（デフォルトは1000）.
    self.max_epoch = 1000
    # 学習用のメソッド.

  def fit(self, x_array, y_array):
    # パターンの次元の記憶
    self.d = len(x_array[0])
    # y_arrayの重複する要素を一つだけ残してできる配列の数を取得することで, クラスの数を得る.
    self.n = len(np.unique(y_array))
    # 重みベクトルを0ベクトルで初期化（重みベクトルの数はクラスの数, 次元はパターンの次元に1足したものとする）.
    self.w = np.zeros((self.n, self.d + 1))
    # パターンの配列を拡張ベクトルの配列にする.
    train_X_ext = np.hstack((np.ones((len(x_array), 1)), x_array))

    # 指定された最大値のエポックまで学習を行う（ただし, epoch変数は1から1000ではなく0から999である）.
    for epoch in range(self.max_epoch):
      all_class_correct = True
      for i, x in enumerate(train_X_ext):
        box=[]
        for i2 in range(self.n):

          # 2. 現在の重みにおける識別関数の結果を計算
          g = np.dot(self.w[i2], x)
          box.append(g)   

        # 3. 識別関数の最大値に応じてクラスを分類
        predicted_class = np.argmax(box)
       
        # 4. 分類結果が誤っているなら重みを更新
        correct_class = y_array[i]
        if correct_class != predicted_class:
          all_class_correct = False
          self.w[correct_class] += self.rho * x
          self.w[predicted_class] -= self.rho * x
      if all_class_correct:
            break # すべて正解していれば終了   
        
    # 評価用のメソッド.
  def predict(self, x_array):
    answer = []
    x_array =  np.hstack((np.ones((len(x_array), 1)), x_array))
    for x in x_array:
        answer.append(self._predict_single(x))
    return np.array(answer)

  # データ一個を評価するメソッド.
  def _predict_single(self, x):
      box1=[]
      for i in range(self.n):
          g = np.dot(self.w[i], x)
          box1.append(g)
      return np.argmax(box1)

# モデルの準備
models = []
models.append(MyPerceptron(rho=1))  # ←自前Perceptronクラス
models.append(Perceptron(eta0=1))   # ←sklearnのPerceptronクラス

# 学習
for model in models:
    model.fit(train_X, train_y)

# 評価
all_results = []
for model in models:
    all_results.append(model.predict(test_X))

# 結果の表示
for results in all_results:
    print(accuracy_score(test_y, results))

# 自前のパーセプトロンとscikit-learnのパーセプトロンの結果を比較
print(all_results[0] == all_results[1])

# 結果の保存
np.savetxt("results.csv", all_results, delimiter=',', fmt="%d")

